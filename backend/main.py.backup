from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, UploadFile, File, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordRequestForm
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from pydantic import BaseModel
from typing import List, Dict, Optional
from sqlalchemy.orm import Session
import subprocess
import tempfile
import os
import yaml
from datetime import datetime, timedelta
import asyncio
import httpx
import json
import re

# Load environment variables from .env file
from dotenv import load_dotenv
load_dotenv()

# Database import
from database import init_db, get_db, AnsibleBuilderPlaybook, AnsibleBuilderInventory, AnsibleBuilderExecution, AnsibleBuilderUser

# Keycloak import (SSO ì¸ì¦)
from keycloak_auth import get_current_user_keycloak, get_optional_user_keycloak, require_keycloak_user
from keycloak_config import (
    KEYCLOAK_SERVER_URL, KEYCLOAK_REALM, KEYCLOAK_CLIENT_ID,
    KEYCLOAK_AUTHORIZATION_URL, KEYCLOAK_TOKEN_URL, KEYCLOAK_LOGOUT_URL
)
KEYCLOAK_ENABLED = True
print("âœ“ Keycloak SSO authentication enabled")

# Ansible í˜¸ìŠ¤íŠ¸ í‚¤ í™•ì¸ ë¹„í™œì„±í™”
os.environ['ANSIBLE_HOST_KEY_CHECKING'] = 'False'

app = FastAPI(title="Ansible Playbook Builder API")

# DB ì´ˆê¸°í™”
@app.on_event("startup")
def startup_event():
    init_db()
    print("Database initialized successfully")
    print("User authentication managed by Keycloak SSO")

# CORS ì„¤ì • - ëª¨ë“  ì˜¤ë¦¬ì§„ í—ˆìš© (í”„ë¡œë•ì…˜ì—ì„œëŠ” íŠ¹ì • ë„ë©”ì¸ë§Œ í—ˆìš©)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # í”„ë¡œë•ì…˜: ["https://your-domain.com"]
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================
# Keycloak SSO ì¸ì¦
# ============================================
# get_optional_user_keycloak: ì¸ì¦ ì„ íƒì  (ë¡œê·¸ì¸ ì—†ì´ë„ ì ‘ê·¼ ê°€ëŠ¥)
# require_keycloak_user: ì¸ì¦ í•„ìˆ˜ (ë¡œê·¸ì¸ í•„ìš”)
# get_current_user_keycloak: ê´€ë¦¬ì ê¶Œí•œ í•„ìˆ˜
# ============================================

# --- START: Added Helper Function for YAML imports ---
def _resolve_yaml_imports(yaml_content: str, base_dir: str) -> str:
    """
    Recursively resolves `import: <file>` statements in a YAML string.
    This is a simple text-based substitution that respects indentation.
    """
    # Regex to find 'import: "path"' and capture the indentation
    import_pattern = re.compile(r'^(?P<indent>\s*)-?\s*import:\s*["\']?(?P<path>[\w\./\\-]+)["\']?\s*$', re.MULTILINE)

    def replacer(match):
        indent = match.group('indent')
        import_path = match.group('path')
        
        # For security, ensure the path is relative and within the project.
        if ".." in import_path:
            return f"{indent}# ERROR: Directory traversal is not allowed."

        abs_path = os.path.normpath(os.path.join(base_dir, import_path))

        if not abs_path.startswith(os.path.abspath(base_dir)):
            return f"{indent}# ERROR: Import path is outside the allowed directory."

        try:
            with open(abs_path, 'r', encoding='utf-8') as f:
                imported_content = f.read()
                
                # Indent the imported content to match the `import:` line's base indentation
                indented_content = '\n'.join([f"{indent}{line}" for line in imported_content.splitlines()])
                
                # Recursively resolve imports in the newly imported content
                return _resolve_yaml_imports(indented_content, base_dir=os.path.dirname(abs_path))
        except FileNotFoundError:
            return f"{indent}# ERROR: Imported file not found at {import_path}"
        except Exception as e:
            return f"{indent}# ERROR: Failed to import file: {e}"

    # Keep replacing until no more imports are found
    resolved_content = yaml_content
    for _ in range(10): # Max 10 levels of recursion
        new_content = import_pattern.sub(replacer, resolved_content)
        if new_content == resolved_content:
            break
        resolved_content = new_content
    else:
        # If the loop completes, there might be a circular import. 
        # We return the content as is and let the YAML parser fail.
        pass

    return resolved_content
# --- END: Added Helper Function ---


class YamlTextImport(BaseModel):
    content: str

# ë°ì´í„° ëª¨ë¸
class Task(BaseModel):
    name: str
    module: str
    params: Dict[str, str]

class Playbook(BaseModel):
    id: Optional[int] = None
    name: str
    hosts: str
    become: bool
    tasks: List[Task]
    created_at: Optional[str] = None

class Inventory(BaseModel):
    id: Optional[int] = None
    name: str
    content: str
    created_at: Optional[str] = None

class ExecutionRequest(BaseModel):
    playbook_id: int
    inventory_id: int
    extra_vars: Optional[Dict[str, str]] = {}

class AWXJobRequest(BaseModel):
    playbook_id: int
    inventory_id: int
    awx_url: str
    awx_username: str
    awx_password: str
    job_template_id: Optional[int] = None

# Playbook CRUD (DB ì‚¬ìš©)
@app.post("/api/playbooks", response_model=Playbook)
async def create_playbook(
    playbook: Playbook,
    request: Request,
    db: Session = Depends(get_db),
    current_user: Optional[AnsibleBuilderUser] = Depends(get_optional_user_keycloak)
):
    db_playbook = AnsibleBuilderPlaybook(
        name=playbook.name,
        hosts=playbook.hosts,
        become=playbook.become,
        tasks=json.dumps([task.dict() for task in playbook.tasks]),
        owner_id=current_user.id if current_user else None,
        owner_username=current_user.username if current_user else None
    )
    db.add(db_playbook)
    db.commit()
    db.refresh(db_playbook)

    # ê°ì‚¬ ë¡œê·¸
    log_action(db, current_user, "CREATE", "playbook", db_playbook.id,
               f"Created playbook: {playbook.name}", request.client.host if request.client else None)

    return Playbook(
        id=db_playbook.id,
        name=db_playbook.name,
        hosts=db_playbook.hosts,
        become=db_playbook.become,
        tasks=[Task(**task) for task in json.loads(db_playbook.tasks)],
        created_at=db_playbook.created_at.isoformat()
    )

@app.get("/api/playbooks", response_model=List[Playbook])
async def list_playbooks(db: Session = Depends(get_db)):
    playbooks = db.query(AnsibleBuilderPlaybook).all()
    return [
        Playbook(
            id=pb.id,
            name=pb.name,
            hosts=pb.hosts,
            become=pb.become,
            tasks=[Task(**task) for task in json.loads(pb.tasks)],
            created_at=pb.created_at.isoformat()
        )
        for pb in playbooks
    ]

@app.get("/api/playbooks/{playbook_id}", response_model=Playbook)
async def get_playbook(playbook_id: int, db: Session = Depends(get_db)):
    pb = db.query(AnsibleBuilderPlaybook).filter(AnsibleBuilderPlaybook.id == playbook_id).first()
    if not pb:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    return Playbook(
        id=pb.id,
        name=pb.name,
        hosts=pb.hosts,
        become=pb.become,
        tasks=[Task(**task) for task in json.loads(pb.tasks)],
        created_at=pb.created_at.isoformat()
    )

@app.put("/api/playbooks/{playbook_id}", response_model=Playbook)
async def update_playbook(
    playbook_id: int,
    playbook: Playbook,
    request: Request,
    db: Session = Depends(get_db),
    current_user: Optional[AnsibleBuilderUser] = Depends(get_optional_user_keycloak)
):
    db_playbook = db.query(AnsibleBuilderPlaybook).filter(AnsibleBuilderPlaybook.id == playbook_id).first()
    if not db_playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")

    # ê¶Œí•œ ì²´í¬
    if current_user and not check_resource_access(current_user, db_playbook.owner_id):
        raise HTTPException(status_code=403, detail="Not authorized to update this playbook")

    db_playbook.name = playbook.name
    db_playbook.hosts = playbook.hosts
    db_playbook.become = playbook.become
    db_playbook.tasks = json.dumps([task.dict() for task in playbook.tasks])
    db_playbook.updated_at = datetime.utcnow()

    db.commit()
    db.refresh(db_playbook)

    # ê°ì‚¬ ë¡œê·¸
    log_action(db, current_user, "UPDATE", "playbook", playbook_id,
               f"Updated playbook: {playbook.name}", request.client.host if request.client else None)

    return Playbook(
        id=db_playbook.id,
        name=db_playbook.name,
        hosts=db_playbook.hosts,
        become=db_playbook.become,
        tasks=[Task(**task) for task in json.loads(db_playbook.tasks)],
        created_at=db_playbook.created_at.isoformat()
    )

@app.delete("/api/playbooks/{playbook_id}")
async def delete_playbook(
    playbook_id: int,
    request: Request,
    db: Session = Depends(get_db),
    current_user: Optional[AnsibleBuilderUser] = Depends(get_optional_user_keycloak)
):
    db_playbook = db.query(AnsibleBuilderPlaybook).filter(AnsibleBuilderPlaybook.id == playbook_id).first()
    if not db_playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")

    # ê¶Œí•œ ì²´í¬
    if current_user and not check_resource_access(current_user, db_playbook.owner_id):
        raise HTTPException(status_code=403, detail="Not authorized to delete this playbook")

    playbook_name = db_playbook.name
    db.delete(db_playbook)
    db.commit()

    # ê°ì‚¬ ë¡œê·¸
    log_action(db, current_user, "DELETE", "playbook", playbook_id,
               f"Deleted playbook: {playbook_name}", request.client.host if request.client else None)

    return {"message": "Playbook deleted"}

# Inventory CRUD (DB ì‚¬ìš©)
@app.post("/api/inventories", response_model=Inventory)
async def create_inventory(
    inventory: Inventory,
    request: Request,
    db: Session = Depends(get_db),
    current_user: Optional[AnsibleBuilderUser] = Depends(get_optional_user_keycloak)
):
    db_inventory = AnsibleBuilderInventory(
        name=inventory.name,
        content=inventory.content,
        owner_id=current_user.id if current_user else None,
        owner_username=current_user.username if current_user else None
    )
    db.add(db_inventory)
    db.commit()
    db.refresh(db_inventory)

    # ê°ì‚¬ ë¡œê·¸
    log_action(db, current_user, "CREATE", "inventory", db_inventory.id,
               f"Created inventory: {inventory.name}", request.client.host if request.client else None)

    return Inventory(
        id=db_inventory.id,
        name=db_inventory.name,
        content=db_inventory.content,
        created_at=db_inventory.created_at.isoformat()
    )

@app.get("/api/inventories", response_model=List[Inventory])
async def list_inventories(db: Session = Depends(get_db)):
    inventories = db.query(AnsibleBuilderInventory).all()
    return [
        Inventory(
            id=inv.id,
            name=inv.name,
            content=inv.content,
            created_at=inv.created_at.isoformat()
        )
        for inv in inventories
    ]

@app.get("/api/inventories/{inventory_id}", response_model=Inventory)
async def get_inventory(inventory_id: int, db: Session = Depends(get_db)):
    inv = db.query(AnsibleBuilderInventory).filter(AnsibleBuilderInventory.id == inventory_id).first()
    if not inv:
        raise HTTPException(status_code=404, detail="Inventory not found")
    
    return Inventory(
        id=inv.id,
        name=inv.name,
        content=inv.content,
        created_at=inv.created_at.isoformat()
    )

@app.delete("/api/inventories/{inventory_id}")
async def delete_inventory(
    inventory_id: int,
    request: Request,
    db: Session = Depends(get_db),
    current_user: Optional[AnsibleBuilderUser] = Depends(get_optional_user_keycloak)
):
    db_inventory = db.query(AnsibleBuilderInventory).filter(AnsibleBuilderInventory.id == inventory_id).first()
    if not db_inventory:
        raise HTTPException(status_code=404, detail="Inventory not found")

    # ê¶Œí•œ ì²´í¬
    if current_user and not check_resource_access(current_user, db_inventory.owner_id):
        raise HTTPException(status_code=403, detail="Not authorized to delete this inventory")

    inventory_name = db_inventory.name
    db.delete(db_inventory)
    db.commit()

    # ê°ì‚¬ ë¡œê·¸
    log_action(db, current_user, "DELETE", "inventory", inventory_id,
               f"Deleted inventory: {inventory_name}", request.client.host if request.client else None)

    return {"message": "Inventory deleted"}

# YAML Import ê¸°ëŠ¥
@app.post("/api/playbooks/import")
async def import_playbook_from_yaml(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """YAML íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì—¬ Playbook ìë™ ìƒì„±"""
    try:
        # íŒŒì¼ ì½ê¸°
        content = await file.read()
        yaml_content = content.decode('utf-8')
        
        # Resolve custom 'import:' statements
        base_dir = "/root/ansible-builder/ansible-builder/backend/playbooks"
        resolved_yaml = _resolve_yaml_imports(yaml_content, base_dir)
        
        # YAML íŒŒì‹±
        parsed_yaml = yaml.safe_load(resolved_yaml)
        
        # YAMLì´ ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° (ë‹¤ì¤‘ play)
        if isinstance(parsed_yaml, list):
            if not parsed_yaml:
                raise HTTPException(status_code=400, detail="Empty YAML file")
            
            # ëª¨ë“  playì˜ taskë¥¼ ìˆ˜ì§‘
            all_tasks = []
            playbook_name = None
            hosts = "all"
            become = False
            
            for play in parsed_yaml:
                if not isinstance(play, dict):
                    continue
                
                # ì²« ë²ˆì§¸ playì˜ ë©”íƒ€ë°ì´í„° ì‚¬ìš©
                if not playbook_name:
                    playbook_name = play.get('name', f'Imported Playbook - {datetime.utcnow().strftime("%Y%m%d_%H%M%S")}')
                    hosts = play.get('hosts', 'all')
                    become = play.get('become', False)
                
                # tasks í‚¤ê°€ ìˆìœ¼ë©´ ìˆ˜ì§‘
                tasks_data = play.get('tasks', [])
                for task in tasks_data:
                    if isinstance(task, dict):
                        all_tasks.append(task)
                
                # roles í‚¤ê°€ ìˆìœ¼ë©´ ê° roleì„ taskë¡œ ë³€í™˜
                roles_data = play.get('roles', [])
                if roles_data:
                    for role in roles_data:
                        if isinstance(role, str):
                            # ë‹¨ìˆœ ë¬¸ìì—´ role
                            all_tasks.append({
                                'name': f'Execute role: {role}',
                                'include_role': {'name': role}
                            })
                        elif isinstance(role, dict):
                            # dict í˜•íƒœì˜ role
                            role_name = role.get('role') or role.get('name', 'unknown')
                            all_tasks.append({
                                'name': f'Execute role: {role_name}',
                                'include_role': role
                            })
            
            tasks_data = all_tasks
        else:
            # ë‹¨ì¼ play
            play = parsed_yaml
            playbook_name = play.get('name', f'Imported Playbook - {datetime.utcnow().strftime("%Y%m%d_%H%M%S")}')
            hosts = play.get('hosts', 'all')
            become = play.get('become', False)
            
            # tasksì™€ roles ëª¨ë‘ ìˆ˜ì§‘
            tasks_data = play.get('tasks', [])
            
            # rolesê°€ ìˆìœ¼ë©´ tasksë¡œ ë³€í™˜
            roles_data = play.get('roles', [])
            if roles_data:
                role_tasks = []
                for role in roles_data:
                    if isinstance(role, str):
                        role_tasks.append({
                            'name': f'Execute role: {role}',
                            'include_role': {'name': role}
                        })
                    elif isinstance(role, dict):
                        role_name = role.get('role') or role.get('name', 'unknown')
                        role_tasks.append({
                            'name': f'Execute role: {role_name}',
                            'include_role': role
                        })
                # rolesë¥¼ tasks ì•ì— ì¶”ê°€
                tasks_data = role_tasks + tasks_data
        
        # Task ë³€í™˜
        converted_tasks = []
        excluded_keys = ['name', 'become', 'when', 'register', 'ignore_errors', 
                       'tags', 'with_items', 'loop', 'until', 'retries', 'delay',
                       'changed_when', 'failed_when', 'notify', 'vars', 'environment',
                       'delegate_to', 'run_once', 'async', 'poll', 'block', 'rescue', 'always']
        
        for task in tasks_data:
            if not isinstance(task, dict):
                continue
            
            task_name = task.get('name', 'Unnamed task')
            
            # ëª¨ë“ˆ ì°¾ê¸°
            module_name = None
            module_params = {}
            
            for key, value in task.items():
                if key not in excluded_keys:
                    module_name = key
                    
                    # ansible.builtin.xxx í˜•íƒœ ì²˜ë¦¬
                    if '.' in module_name:
                        module_name = module_name.split('.')[-1]
                    
                    if isinstance(value, dict):
                        module_params = value
                    elif isinstance(value, str):
                        if module_name in ['command', 'shell']:
                            module_params = {'cmd': value}
                        elif module_name in ['apt', 'yum', 'package']:
                            module_params = {'name': value, 'state': 'present'}
                        elif module_name in ['copy', 'template']:
                            module_params = {'src': '', 'dest': value}
                        elif module_name in ['include_role']:
                            module_params = {'name': value}
                        else:
                            module_params = {'name': value}
                    elif isinstance(value, list):
                        module_params = {'items': ', '.join(str(v) for v in value)}
                    else:
                        module_params = {'value': str(value)}
                    break
            
            if module_name:
                params_dict = {}
                for k, v in module_params.items():
                    if isinstance(v, (list, dict)):
                        params_dict[k] = json.dumps(v) if isinstance(v, dict) else str(v)
                    else:
                        params_dict[k] = str(v) if v is not None else ""
                
                converted_tasks.append({
                    'name': task_name,
                    'module': module_name,
                    'params': params_dict
                })
        
        if not converted_tasks:
            raise HTTPException(status_code=400, detail="No valid tasks found in YAML")
        
        # DBì— ì €ì¥
        db_playbook = AnsibleBuilderPlaybook(
            name=playbook_name,
            hosts=hosts,
            become=become,
            tasks=json.dumps(converted_tasks)
        )
        db.add(db_playbook)
        db.commit()
        db.refresh(db_playbook)
        
        return {
            "status": "success",
            "playbook_id": db_playbook.id,
            "playbook_name": playbook_name,
            "tasks_count": len(converted_tasks),
            "message": f"Successfully imported playbook with {len(converted_tasks)} tasks"
        }
        
    except yaml.YAMLError as e:
        raise HTTPException(status_code=400, detail=f"Invalid YAML format: {str(e)}")
    except Exception as e:
        import traceback
        error_detail = f"Import failed: {str(e)}\n{traceback.format_exc()}"
        print(error_detail)
        raise HTTPException(status_code=500, detail=f"Import failed: {str(e)}")

@app.post("/api/playbooks/import-text")
async def import_playbook_from_text(data: YamlTextImport, db: Session = Depends(get_db)):
    """YAML í…ìŠ¤íŠ¸ë¥¼ ì§ì ‘ ì…ë ¥í•˜ì—¬ Playbook ìë™ ìƒì„±"""
    try:
        yaml_text = data.content
        # Resolve custom 'import:' statements
        base_dir = "/root/ansible-builder/ansible-builder/backend/playbooks"
        resolved_yaml = _resolve_yaml_imports(yaml_text, base_dir)

        # YAML íŒŒì‹±
        parsed_yaml = yaml.safe_load(resolved_yaml)
        
        # YAMLì´ ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° ì²« ë²ˆì§¸ play ì‚¬ìš©
        if isinstance(parsed_yaml, list):
            if not parsed_yaml:
                raise HTTPException(status_code=400, detail="Empty YAML content")
            play = parsed_yaml[0]
        else:
            play = parsed_yaml
        
        # Playbook ì •ë³´ ì¶”ì¶œ
        playbook_name = play.get('name', f'Imported Playbook - {datetime.utcnow().strftime("%Y%m%d_%H%M%S")}')
        hosts = play.get('hosts', 'all')
        become = play.get('become', False)
        tasks_data = play.get('tasks', [])
        
        # Task ë³€í™˜
        converted_tasks = []
        for task in tasks_data:
            if not isinstance(task, dict):
                continue
            
            task_name = task.get('name', 'Unnamed task')
            
            # ëª¨ë“ˆ ì°¾ê¸°
            module_name = None
            module_params = {}
            
            for key, value in task.items():
                if key not in ['name', 'become', 'when', 'register', 'ignore_errors', 'tags']:
                    module_name = key
                    if isinstance(value, dict):
                        module_params = value
                    elif isinstance(value, str):
                        module_params = {'cmd': value} if module_name in ['command', 'shell'] else {'name': value}
                    break
            
            if module_name:
                params_dict = {}
                for k, v in module_params.items():
                    params_dict[k] = str(v) if v is not None else ""
                
                converted_tasks.append({
                    'name': task_name,
                    'module': module_name,
                    'params': params_dict
                })
        
        # DBì— ì €ì¥
        db_playbook = AnsibleBuilderPlaybook(
            name=playbook_name,
            hosts=hosts,
            become=become,
            tasks=json.dumps(converted_tasks)
        )
        db.add(db_playbook)
        db.commit()
        db.refresh(db_playbook)
        
        return {
            "status": "success",
            "playbook_id": db_playbook.id,
            "playbook_name": playbook_name,
            "tasks_count": len(converted_tasks),
            "message": f"Successfully imported playbook with {len(converted_tasks)} tasks"
        }
        
    except yaml.YAMLError as e:
        raise HTTPException(status_code=400, detail=f"Invalid YAML format: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Import failed: {str(e)}")


# import script

@app.post("/api/playbooks/import-script")
async def import_script_as_playbook(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """ì…¸ ìŠ¤í¬ë¦½íŠ¸(.sh, .bash) íŒŒì¼ì„ Playbookìœ¼ë¡œ ë³€í™˜"""
    try:
        content = await file.read()
        script_content = content.decode('utf-8')
        
        if not script_content.strip():
            raise HTTPException(status_code=400, detail="Empty script file")
        
        # íŒŒì¼ëª…ì—ì„œ playbook ì´ë¦„ ìƒì„±
        script_name = file.filename.replace('.sh', '').replace('.bash', '').replace('.zsh', '')
        playbook_name = f"Script_{script_name}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        
        # ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ tasks ìƒì„±
        tasks = []
        lines = script_content.split('\n')
        
        # ì „ì²´ ìŠ¤í¬ë¦½íŠ¸ë¥¼ í•˜ë‚˜ì˜ shell taskë¡œ ë³€í™˜í•˜ëŠ” ê°„ë‹¨í•œ ë°©ì‹
        # ë˜ëŠ” ë¼ì¸ë³„ë¡œ ë¶„ì„í•˜ì—¬ ê°œë³„ taskë¡œ ë¶„ë¦¬
        
        # ë°©ë²• 1: ì „ì²´ ìŠ¤í¬ë¦½íŠ¸ë¥¼ í•˜ë‚˜ì˜ taskë¡œ
        tasks.append({
            "name": f"Execute {script_name} script",
            "module": "shell",
            "params": {
                "cmd": script_content,
                "executable": "/bin/bash"
            }
        })
        
        # ë°©ë²• 2: ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì˜ë¯¸ìˆëŠ” taskë¡œ ë¶„ë¦¬
        current_block = []
        block_name = "Initial setup"
        
        for line in lines:
            stripped = line.strip()
            
            # ë¹ˆ ì¤„ì´ë‚˜ ì£¼ì„ì€ ë¸”ë¡ êµ¬ë¶„ìë¡œ ì‚¬ìš©
            if not stripped or stripped.startswith('#'):
                if current_block and not stripped.startswith('#!'):
                    # í˜„ì¬ ë¸”ë¡ì„ taskë¡œ ì¶”ê°€
                    if len(current_block) > 0:
                        tasks.append({
                            "name": block_name,
                            "module": "shell",
                            "params": {
                                "cmd": '\n'.join(current_block),
                                "executable": "/bin/bash"
                            }
                        })
                    current_block = []
                    
                # ì£¼ì„ì—ì„œ task ì´ë¦„ ì¶”ì¶œ
                if stripped.startswith('#') and not stripped.startswith('#!'):
                    block_name = stripped.lstrip('#').strip() or "Execute commands"
                continue
            
            # apt/yum install ëª…ë ¹ ê°ì§€
            if 'apt-get install' in stripped or 'apt install' in stripped:
                packages = []
                for word in stripped.split():
                    if word not in ['apt-get', 'apt', 'install', 'sudo', '-y', '--yes']:
                        packages.append(word)
                
                if packages:
                    tasks.append({
                        "name": f"Install packages: {', '.join(packages)}",
                        "module": "apt",
                        "params": {
                            "name": ','.join(packages),
                            "state": "present",
                            "update_cache": "yes"
                        }
                    })
                    continue
            
            if 'yum install' in stripped:
                packages = []
                for word in stripped.split():
                    if word not in ['yum', 'install', 'sudo', '-y']:
                        packages.append(word)
                
                if packages:
                    tasks.append({
                        "name": f"Install packages: {', '.join(packages)}",
                        "module": "yum",
                        "params": {
                            "name": ','.join(packages),
                            "state": "present"
                        }
                    })
                    continue
            
            # systemctl ëª…ë ¹ ê°ì§€
            if 'systemctl' in stripped:
                parts = stripped.split()
                if 'start' in parts:
                    service_idx = parts.index('start') + 1
                    if service_idx < len(parts):
                        tasks.append({
                            "name": f"Start service {parts[service_idx]}",
                            "module": "service",
                            "params": {
                                "name": parts[service_idx],
                                "state": "started"
                            }
                        })
                        continue
                elif 'enable' in parts:
                    service_idx = parts.index('enable') + 1
                    if service_idx < len(parts):
                        tasks.append({
                            "name": f"Enable service {parts[service_idx]}",
                            "module": "service",
                            "params": {
                                "name": parts[service_idx],
                                "enabled": "yes"
                            }
                        })
                        continue
            
            # mkdir ëª…ë ¹ ê°ì§€
            if stripped.startswith('mkdir'):
                parts = stripped.split()
                if len(parts) >= 2:
                    path = parts[-1]
                    tasks.append({
                        "name": f"Create directory {path}",
                        "module": "file",
                        "params": {
                            "path": path,
                            "state": "directory",
                            "mode": "0755"
                        }
                    })
                    continue
            
            # ì¼ë°˜ ëª…ë ¹ì€ ë¸”ë¡ì— ì¶”ê°€
            current_block.append(line)
        
        # ë§ˆì§€ë§‰ ë¸”ë¡ ì²˜ë¦¬
        if current_block:
            tasks.append({
                "name": block_name,
                "module": "shell",
                "params": {
                    "cmd": '\n'.join(current_block),
                    "executable": "/bin/bash"
                }
            })
        
        # tasksê°€ ì—†ìœ¼ë©´ ì „ì²´ ìŠ¤í¬ë¦½íŠ¸ë¥¼ í•˜ë‚˜ì˜ taskë¡œ
        if not tasks:
            tasks.append({
                "name": f"Execute {script_name}",
                "module": "shell",
                "params": {
                    "cmd": script_content,
                    "executable": "/bin/bash"
                }
            })
        
        # DBì— ì €ì¥
        db_playbook = AnsibleBuilderPlaybook(
            name=playbook_name,
            hosts="all",
            become=True,  # ìŠ¤í¬ë¦½íŠ¸ëŠ” ë³´í†µ sudo ê¶Œí•œ í•„ìš”
            tasks=json.dumps(tasks)
        )
        db.add(db_playbook)
        db.commit()
        db.refresh(db_playbook)
        
        return {
            "status": "success",
            "playbook_id": db_playbook.id,
            "playbook_name": playbook_name,
            "tasks_count": len(tasks),
            "message": f"Successfully converted script to playbook with {len(tasks)} tasks"
        }
        
    except UnicodeDecodeError:
        raise HTTPException(status_code=400, detail="Invalid file encoding. Please use UTF-8")
    except Exception as e:
        import traceback
        error_detail = f"Import failed: {str(e)}\n{traceback.format_exc()}"
        print(error_detail)
        raise HTTPException(status_code=500, detail=f"Import failed: {str(e)}")


@app.post("/api/playbooks/import-script-text")
async def import_script_text_as_playbook(data: dict, db: Session = Depends(get_db)):
    """ìŠ¤í¬ë¦½íŠ¸ í…ìŠ¤íŠ¸ë¥¼ ì§ì ‘ ì…ë ¥í•˜ì—¬ Playbook ìƒì„±"""
    try:
        script_text = data.get('content', '')
        playbook_name = data.get('name', f'Script_Playbook_{datetime.utcnow().strftime("%Y%m%d_%H%M%S")}')
        
        if not script_text.strip():
            raise HTTPException(status_code=400, detail="Empty script content")
        
        # ìŠ¤í¬ë¦½íŠ¸ ë¶„ì„ ë° task ìƒì„± (ìœ„ì™€ ë™ì¼í•œ ë¡œì§)
        tasks = []
        lines = script_text.split('\n')
        
        current_block = []
        block_name = "Execute script commands"
        
        for line in lines:
            stripped = line.strip()
            
            if not stripped or stripped.startswith('#'):
                if current_block and not stripped.startswith('#!'):
                    if len(current_block) > 0:
                        tasks.append({
                            "name": block_name,
                            "module": "shell",
                            "params": {
                                "cmd": '\n'.join(current_block),
                                "executable": "/bin/bash"
                            }
                        })
                    current_block = []
                
                if stripped.startswith('#') and not stripped.startswith('#!'):
                    block_name = stripped.lstrip('#').strip() or "Execute commands"
                continue
            
            # íŒ¨í‚¤ì§€ ì„¤ì¹˜ ëª…ë ¹ ê°ì§€
            if 'apt-get install' in stripped or 'apt install' in stripped:
                packages = [w for w in stripped.split() 
                           if w not in ['apt-get', 'apt', 'install', 'sudo', '-y', '--yes']]
                if packages:
                    tasks.append({
                        "name": f"Install packages: {', '.join(packages)}",
                        "module": "apt",
                        "params": {
                            "name": ','.join(packages),
                            "state": "present",
                            "update_cache": "yes"
                        }
                    })
                    continue
            
            if 'yum install' in stripped:
                packages = [w for w in stripped.split() 
                           if w not in ['yum', 'install', 'sudo', '-y']]
                if packages:
                    tasks.append({
                        "name": f"Install packages: {', '.join(packages)}",
                        "module": "yum",
                        "params": {
                            "name": ','.join(packages),
                            "state": "present"
                        }
                    })
                    continue
            
            # systemctl ëª…ë ¹ ì²˜ë¦¬
            if 'systemctl' in stripped:
                parts = stripped.split()
                if 'start' in parts:
                    service_idx = parts.index('start') + 1
                    if service_idx < len(parts):
                        tasks.append({
                            "name": f"Start service {parts[service_idx]}",
                            "module": "service",
                            "params": {
                                "name": parts[service_idx],
                                "state": "started"
                            }
                        })
                        continue
                elif 'enable' in parts:
                    service_idx = parts.index('enable') + 1
                    if service_idx < len(parts):
                        tasks.append({
                            "name": f"Enable service {parts[service_idx]}",
                            "module": "service",
                            "params": {
                                "name": parts[service_idx],
                                "enabled": "yes"
                            }
                        })
                        continue
            
            # mkdir ëª…ë ¹
            if stripped.startswith('mkdir'):
                parts = stripped.split()
                if len(parts) >= 2:
                    path = parts[-1]
                    tasks.append({
                        "name": f"Create directory {path}",
                        "module": "file",
                        "params": {
                            "path": path,
                            "state": "directory",
                            "mode": "0755"
                        }
                    })
                    continue
            
            current_block.append(line)
        
        # ë§ˆì§€ë§‰ ë¸”ë¡ ì²˜ë¦¬
        if current_block:
            tasks.append({
                "name": block_name,
                "module": "shell",
                "params": {
                    "cmd": '\n'.join(current_block),
                    "executable": "/bin/bash"
                }
            })
        
        # tasksê°€ ì—†ìœ¼ë©´ ì „ì²´ë¥¼ í•˜ë‚˜ì˜ taskë¡œ
        if not tasks:
            tasks.append({
                "name": "Execute script",
                "module": "shell",
                "params": {
                    "cmd": script_text,
                    "executable": "/bin/bash"
                }
            })
        
        # DBì— ì €ì¥
        db_playbook = AnsibleBuilderPlaybook(
            name=playbook_name,
            hosts="all",
            become=True,
            tasks=json.dumps(tasks)
        )
        db.add(db_playbook)
        db.commit()
        db.refresh(db_playbook)
        
        return {
            "status": "success",
            "playbook_id": db_playbook.id,
            "playbook_name": playbook_name,
            "tasks_count": len(tasks),
            "message": f"Successfully converted script to playbook with {len(tasks)} tasks"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Import failed: {str(e)}")


# Playbook ì‹¤í–‰
def generate_yaml(playbook: dict) -> str:
    yaml_content = {
        "name": playbook["name"],
        "hosts": playbook["hosts"],
        "tasks": []
    }
    
    if playbook["become"]:
        yaml_content["become"] = True
    
    for task in playbook["tasks"]:
        task_dict = {
            "name": task["name"],
            task["module" ]: {k: v for k, v in task["params"].items() if v}
        }
        yaml_content["tasks"].append(task_dict)
    
    return yaml.dump([yaml_content], default_flow_style=False)

async def run_ansible_playbook(exec_id: int, playbook_content: str, inventory_content: str, extra_vars: dict, db: Session):
    try:
        with tempfile.NamedTemporaryFile(mode='w', suffix='.yml', delete=False) as pb_file:
            pb_file.write(playbook_content)
            playbook_path = pb_file.name
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.ini', delete=False) as inv_file:
            inv_file.write(inventory_content)
            inventory_path = inv_file.name
        
        cmd = [
            "ansible-playbook",
            "-i", inventory_path,
            playbook_path,
            "-c", "local"
        ]
        
        if extra_vars:
            extra_vars_str = " ".join([f"{k}={v}" for k, v in extra_vars.items()])
            cmd.extend(["-e", extra_vars_str])
        
        execution = db.query(AnsibleBuilderExecution).filter(AnsibleBuilderExecution.id == exec_id).first()
        execution.status = "running"
        execution.output = ""
        db.commit()
        
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.STDOUT
        )
        
        # ì‹¤ì‹œê°„ ì¶œë ¥ ìˆ˜ì§‘
        output = ""
        while True:
            line = await process.stdout.readline()
            if not line:
                break
            decoded_line = line.decode()
            output += decoded_line
            execution.output = output
            db.commit()
        
        await process.wait()
        
        execution.status = "completed" if process.returncode == 0 else "failed"
        execution.return_code = process.returncode
        execution.ended_at = datetime.utcnow()
        db.commit()
        
        os.unlink(playbook_path)
        os.unlink(inventory_path)
        
    except Exception as e:
        execution = db.query(AnsibleBuilderExecution).filter(AnsibleBuilderExecution.id == exec_id).first()
        execution.status = "error"
        execution.error = str(e)
        execution.ended_at = datetime.utcnow()
        db.commit()

@app.post("/api/execute")
async def execute_playbook(request: ExecutionRequest, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    playbook = db.query(AnsibleBuilderPlaybook).filter(AnsibleBuilderPlaybook.id == request.playbook_id).first()
    if not playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    inventory = db.query(AnsibleBuilderInventory).filter(AnsibleBuilderInventory.id == request.inventory_id).first()
    if not inventory:
        raise HTTPException(status_code=404, detail="Inventory not found")
    
    playbook_dict = {
        "name": playbook.name,
        "hosts": playbook.hosts,
        "become": playbook.become,
        "tasks": json.loads(playbook.tasks)
    }
    
    playbook_yaml = generate_yaml(playbook_dict)
    
    execution = AnsibleBuilderExecution(
        playbook_id=request.playbook_id,
        inventory_id=request.inventory_id,
        status="pending"
    )
    db.add(execution)
    db.commit()
    db.refresh(execution)
    
    background_tasks.add_task(
        run_ansible_playbook,
        execution.id,
        playbook_yaml,
        inventory.content,
        request.extra_vars,
        db
    )
    
    return {"execution_id": execution.id, "status": "pending"}

@app.get("/api/executions/{exec_id}")
async def get_execution_status(exec_id: int, db: Session = Depends(get_db)):
    execution = db.query(AnsibleBuilderExecution).filter(AnsibleBuilderExecution.id == exec_id).first()
    if not execution:
        raise HTTPException(status_code=404, detail="Execution not found")
    
    return {
        "id": execution.id,
        "playbook_id": execution.playbook_id,
        "inventory_id": execution.inventory_id,
        "status": execution.status,
        "output": execution.output,
        "error": execution.error,
        "return_code": execution.return_code,
        "started_at": execution.started_at.isoformat() if execution.started_at else None,
        "ended_at": execution.ended_at.isoformat() if execution.ended_at else None
    }

@app.get("/api/executions")
async def list_executions(db: Session = Depends(get_db)):
    executions = db.query(AnsibleBuilderExecution).order_by(AnsibleBuilderExecution.started_at.desc()).all()
    return [
        {
            "id": ex.id,
            "playbook_id": ex.playbook_id,
            "inventory_id": ex.inventory_id,
            "status": ex.status,
            "output": ex.output,
            "error": ex.error,
            "return_code": ex.return_code,
            "started_at": ex.started_at.isoformat() if ex.started_at else None,
            "ended_at": ex.ended_at.isoformat() if ex.ended_at else None
        }
        for ex in executions
    ]

@app.post("/api/playbooks/{playbook_id}/yaml")
async def generate_playbook_yaml(playbook_id: int, db: Session = Depends(get_db)):
    playbook = db.query(AnsibleBuilderPlaybook).filter(AnsibleBuilderPlaybook.id == playbook_id).first()
    if not playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    playbook_dict = {
        "name": playbook.name,
        "hosts": playbook.hosts,
        "become": playbook.become,
        "tasks": json.loads(playbook.tasks)
    }
    yaml_content = generate_yaml(playbook_dict)
    
    return {"yaml": yaml_content}

@app.get("/api")
async def api_root():
    return {
        "message": "Ansible Playbook Builder API",
        "version": "1.0.0",
        "endpoints": {
            "playbooks": "/api/playbooks",
            "inventories": "/api/inventories",
            "execute": "/api/execute",
            "executions": "/api/executions"
        }
    }

@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}


@app.post("/api/awx/create-template")
async def create_awx_job_template(request: AWXJobRequest, db: Session = Depends(get_db)):
    """AWXì— ìƒˆë¡œìš´ Job Template ìƒì„±"""
    
    # ğŸ”´ DB ê°ì²´ ì¡°íšŒ
    playbook = db.query(AnsibleBuilderPlaybook).filter(
        AnsibleBuilderPlaybook.id == request.playbook_id
    ).first()
    if not playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    inventory = db.query(AnsibleBuilderInventory).filter(
        AnsibleBuilderInventory.id == request.inventory_id
    ).first()
    if not inventory:
        raise HTTPException(status_code=404, detail="Inventory not found")
    
    # ğŸ”´ DB ê°ì²´ë¥¼ dictë¡œ ë³€í™˜
    playbook_dict = {
        "name": playbook.name,
        "hosts": playbook.hosts,
        "become": playbook.become,
        "tasks": json.loads(playbook.tasks)
    }
    
    inventory_dict = {
        "id": inventory.id,
        "name": inventory.name,
        "content": inventory.content
    }
    
    try:
        async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
            auth = (request.awx_username, request.awx_password)
            
            # 0. ì¸ì¦ í…ŒìŠ¤íŠ¸
            test_res = await client.get(f"{request.awx_url}/api/v2/me/", auth=auth)
            if test_res.status_code != 200:
                raise HTTPException(status_code=401, detail="AWX authentication failed")
            
            # 1. Organization ì¡°íšŒ
            orgs_res = await client.get(f"{request.awx_url}/api/v2/organizations/", auth=auth)
            if orgs_res.status_code != 200:
                raise HTTPException(status_code=400, detail="Failed to get organizations")
            
            orgs = orgs_res.json()
            if not orgs.get('results'):
                raise HTTPException(status_code=400, detail="No organizations found")
            org_id = orgs['results'][0]['id']
            
            # 2. Project ì¡°íšŒ
            projects_url = f"{request.awx_url}/api/v2/projects/"
            projects_res = await client.get(projects_url, auth=auth)
            if projects_res.status_code != 200:
                raise HTTPException(status_code=400, detail="Failed to get projects")
            
            projects = projects_res.json()
            if not projects.get('results'):
                raise HTTPException(status_code=400, detail="No projects found")
            
            # Demo Project ì°¾ê¸°
            project_id = None
            for proj in projects['results']:
                if 'demo' in proj['name'].lower():
                    project_id = proj['id']
                    break
            
            if not project_id:
                project_id = projects['results'][0]['id']
            
            # 3. Inventory ìƒì„±
            inventory_name = f"ansible_builder_{inventory_dict['id']}"
            inventories_url = f"{request.awx_url}/api/v2/inventories/"
            
            # ê¸°ì¡´ Inventory í™•ì¸
            inv_check = await client.get(f"{inventories_url}?name={inventory_name}", auth=auth)
            if inv_check.status_code == 200 and inv_check.json().get('count', 0) > 0:
                awx_inventory_id = inv_check.json()['results'][0]['id']
            else:
                # ìƒˆ Inventory ìƒì„±
                inv_data = {
                    "name": inventory_name,
                    "description": "Auto-created by Ansible Builder",
                    "organization": org_id
                }
                inv_res = await client.post(inventories_url, auth=auth, json=inv_data)
                if inv_res.status_code not in [200, 201]:
                    raise HTTPException(status_code=400, detail=f"Failed to create inventory: {inv_res.text}")
                awx_inventory_id = inv_res.json()['id']
            
            # Host ì¶”ê°€ (ê°„ì†Œí™”)
            hosts_url = f"{request.awx_url}/api/v2/inventories/{awx_inventory_id}/hosts/"
            for line in inventory_dict['content'].split('\n'):
                line = line.strip()
                if not line or line.startswith('[') or line.startswith('#'):
                    continue
                
                parts = line.split()
                if not parts:
                    continue
                
                hostname = parts[0]
                host_vars = {}
                for part in parts[1:]:
                    if '=' in part:
                        key, value = part.split('=', 1)
                        host_vars[key] = value
                
                host_data = {
                    "name": hostname,
                    "description": "Auto-created",
                    "enabled": True
                }
                
                if host_vars:
                    host_data["variables"] = yaml.dump(host_vars)
                
                # ê¸°ì¡´ í˜¸ìŠ¤íŠ¸ í™•ì¸
                check_url = f"{hosts_url}?name={hostname}"
                check_res = await client.get(check_url, auth=auth)
                
                if not (check_res.status_code == 200 and check_res.json().get('count', 0) > 0):
                    await client.post(hosts_url, auth=auth, json=host_data)
            
            # 4. Credential ì¡°íšŒ
            creds_url = f"{request.awx_url}/api/v2/credentials/"
            creds_res = await client.get(creds_url, auth=auth)
            credential_id = None
            
            if creds_res.status_code == 200:
                creds = creds_res.json()
                for cred in creds.get('results', []):
                    if 'gaia_bot' in cred.get('name', '').lower():
                        credential_id = cred['id']
                        break
                
                if not credential_id and creds.get('results'):
                    credential_id = creds['results'][0]['id']
            
            # â­ 5. Job Template ìƒì„± (templates_url ì •ì˜)
            templates_url = f"{request.awx_url}/api/v2/job_templates/"
            template_name = f"{playbook_dict['name']}_{inventory_dict['name']}"
            
            # ê¸°ì¡´ Template í™•ì¸
            template_check = await client.get(f"{templates_url}?name={template_name}", auth=auth)
            if template_check.status_code == 200 and template_check.json().get('count', 0) > 0:
                existing = template_check.json()['results'][0]
                return {
                    "status": "success",
                    "template_id": existing['id'],
                    "template_name": template_name,
                    "template_url": f"{request.awx_url}/#/templates/job_template/{existing['id']}",
                    "message": "Job Template already exists"
                }
            
            # Template ë°ì´í„° ìƒì„±
            template_data = {
                "name": template_name,
                "description": f"Auto-created: {playbook_dict['name']}",
                "job_type": "run",
                "inventory": awx_inventory_id,
                "project": project_id,
                "playbook": "ansible_builder_executor.yml",
                "verbosity": 2,
                "ask_variables_on_launch": True,  # â­ ì´ê²ƒë§Œìœ¼ë¡œ ë¶€ì¡±
                "ask_limit_on_launch": False,
                "ask_tags_on_launch": False,
                "ask_skip_tags_on_launch": False,
                "ask_job_type_on_launch": False,
                "ask_verbosity_on_launch": False,
                "ask_inventory_on_launch": False,
                "ask_credential_on_launch": False,
                "extra_vars": ""  # â­ ë¹ˆ ë¬¸ìì—´ (ì¤‘ìš”)
            }
            
            if credential_id:
                template_data["credentials"] = [credential_id]
            
            # Template ìƒì„± ìš”ì²­
            template_res = await client.post(templates_url, auth=auth, json=template_data)
            if template_res.status_code not in [200, 201]:
                raise HTTPException(status_code=400, detail=f"Failed to create job template: {template_res.text}")
            
            template_result = template_res.json()
            
            return {
                "status": "success",
                "template_id": template_result['id'],
                "template_name": template_name,
                "template_url": f"{request.awx_url}/#/templates/job_template/{template_result['id']}",
                "project_id": project_id,
                "inventory_id": awx_inventory_id,
                "credential_id": credential_id,
                "message": f"Job Template '{template_name}' created successfully"
            }
            
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        error_detail = f"Error: {str(e)}\n{traceback.format_exc()}"
        print(error_detail)
        raise HTTPException(status_code=500, detail=error_detail)
    """AWXì— ìƒˆë¡œìš´ Job Template ìƒì„±"""
    # DEBUG: Write the executor content to a file for verification
    debug_file_path = "ansible_builder_executor_sent_to_awx.yml"
    with open(debug_file_path, "w") as f:
        f.write(EXECUTOR_PLAYBOOK_CONTENT)

    # ğŸ”´ DB ê°ì²´ ì¡°íšŒ
    playbook = db.query(AnsibleBuilderPlaybook).filter(AnsibleBuilderPlaybook.id == request.playbook_id).first()
    if not playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    inventory = db.query(AnsibleBuilderInventory).filter(
        AnsibleBuilderInventory.id == request.inventory_id
    ).first()
    if not inventory:
        raise HTTPException(status_code=404, detail="Inventory not found")
    
    # ğŸ”´ DB ê°ì²´ë¥¼ dictë¡œ ë³€í™˜ (ì¤‘ìš”!)
    playbook_dict = {
        "name": playbook.name,
        "hosts": playbook.hosts,
        "become": playbook.become,
        "tasks": json.loads(playbook.tasks)
    }
    
    inventory_dict = {
        "id": inventory.id,
        "name": inventory.name,
        "content": inventory.content
    }
    
    try:
        async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
            auth = (request.awx_username, request.awx_password)
            
            # 0. ì¸ì¦ í…ŒìŠ¤íŠ¸
            try:
                test_res = await client.get(f"{request.awx_url}/api/v2/me/", auth=auth)
                if test_res.status_code != 200:
                    raise HTTPException(status_code=401, detail=f"AWX authentication failed: {test_res.text}")
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Cannot connect to AWX: {str(e)}")
            
            # 1. Organization ì¡°íšŒ
            orgs_res = await client.get(f"{request.awx_url}/api/v2/organizations/", auth=auth)
            if orgs_res.status_code != 200:
                raise HTTPException(status_code=400, detail=f"Failed to get organizations: {orgs_res.text}")
            orgs = orgs_res.json()
            if not orgs.get('results'):
                raise HTTPException(status_code=400, detail="No organizations found in AWX")
            org_id = orgs['results'][0]['id']
            
            # 2. ê¸°ì¡´ Project ì¤‘ í•˜ë‚˜ ì‚¬ìš© (Demo Project ìš°ì„ )
            projects_url = f"{request.awx_url}/api/v2/projects/"
            projects_res = await client.get(projects_url, auth=auth)
            if projects_res.status_code != 200:
                raise HTTPException(status_code=400, detail="Failed to get projects")
            
            projects = projects_res.json()
            if not projects.get('results'):
                raise HTTPException(status_code=400, detail="No projects found in AWX. Please create at least one project with playbooks first.")
            
            # Demo Project ì°¾ê¸° ë˜ëŠ” ì²« ë²ˆì§¸ Project ì‚¬ìš©
            project_id = None
            demo_playbook = None
            for proj in projects['results']:
                if 'demo' in proj['name'].lower() or 'example' in proj['name'].lower():
                    project_id = proj['id']
                    playbooks_url = f"{request.awx_url}/api/v2/projects/{project_id}/playbooks/"
                    pb_res = await client.get(playbooks_url, auth=auth)
                    if pb_res.status_code == 200:
                        pbs = pb_res.json()
                        if pbs:
                            demo_playbook = pbs[0]
                    break
            
            if not project_id:
                project_id = projects['results'][0]['id']
                playbooks_url = f"{request.awx_url}/api/v2/projects/{project_id}/playbooks/"
                pb_res = await client.get(playbooks_url, auth=auth)
                if pb_res.status_code == 200:
                    pbs = pb_res.json()
                    if pbs:
                        demo_playbook = pbs[0]
            
            if not demo_playbook:
                raise HTTPException(status_code=400, detail="No playbooks found in AWX projects. Please sync a project first.")
            
            # 3. Inventory ìƒì„±
            inventory_name = f"ansible_builder_{inventory_dict['id']}"
            inventories_url = f"{request.awx_url}/api/v2/inventories/"
            
            # ê¸°ì¡´ Inventory í™•ì¸
            inv_check = await client.get(f"{inventories_url}?name={inventory_name}", auth=auth)
            if inv_check.status_code == 200 and inv_check.json().get('count', 0) > 0:
                awx_inventory_id = inv_check.json()['results'][0]['id']
                # ê¸°ì¡´ Inventoryì˜ Host ì‚­ì œ í›„ ì¬ìƒì„±
                hosts_list_url = f"{request.awx_url}/api/v2/inventories/{awx_inventory_id}/hosts/"
                existing_hosts = await client.get(hosts_list_url, auth=auth)
                if existing_hosts.status_code == 200:
                    for host in existing_hosts.json().get('results', []):
                        await client.delete(f"{request.awx_url}/api/v2/hosts/{host['id']}/", auth=auth)
            else:
                # ìƒˆ Inventory ìƒì„±
                inv_data = {
                    "name": inventory_name,
                    "description": f"Auto-created by Ansible Builder",
                    "organization": org_id
                }
                inv_res = await client.post(inventories_url, auth=auth, json=inv_data)
                if inv_res.status_code not in [200, 201]:
                    raise HTTPException(status_code=400, detail=f"Failed to create inventory: {inv_res.text}")
                awx_inventory_id = inv_res.json()['id']
            
            # Host ì¶”ê°€ - ì² ì €í•œ ë³€ìˆ˜ í•„í„°ë§ ë° ê·¸ë£¹ í• ë‹¹
            hosts_url = f"{request.awx_url}/api/v2/inventories/{awx_inventory_id}/hosts/"
            groups_url = f"{request.awx_url}/api/v2/inventories/{awx_inventory_id}/groups/"
            
            current_group = None
            current_group_id = None
            added_hosts = set()
            skip_section = False
            created_groups = {}  # ê·¸ë£¹ëª… -> ê·¸ë£¹ID ë§¤í•‘
            
            # ì˜ˆì•½ëœ ê·¸ë£¹ëª… (AWXì—ì„œ ìƒì„± ë¶ˆê°€)
            RESERVED_GROUPS = ['all', 'ungrouped', 'localhost']
            
            for line in inventory_dict['content'].split('\n'):
                line = line.strip()
                
                if not line:
                    continue
                
                # ì£¼ì„ ì²˜ë¦¬
                if line.startswith('#') or line.startswith(';'):
                    continue
                
                # ê·¸ë£¹ í—¤ë”
                if line.startswith('[') and line.endswith(']'):
                    current_group = line[1:-1]
                    
                    if ':vars' in current_group or ':children' in current_group:
                        skip_section = True
                        current_group_id = None
                        print(f"ğŸš« Skip section: [{current_group}]")
                    else:
                        skip_section = False
                        print(f"âœ… Process section: [{current_group}]")
                        
                        # ì˜ˆì•½ëœ ê·¸ë£¹ì€ ìƒì„±í•˜ì§€ ì•ŠìŒ (í˜¸ìŠ¤íŠ¸ëŠ” ì§ì ‘ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€)
                        if current_group.lower() in RESERVED_GROUPS:
                            print(f"âš ï¸ Reserved group '{current_group}', skipping group creation")
                            current_group_id = None
                        # AWXì— ê·¸ë£¹ ìƒì„±
                        elif current_group not in created_groups:
                            try:
                                # ê¸°ì¡´ ê·¸ë£¹ í™•ì¸
                                check_group = await client.get(f"{groups_url}?name={current_group}", auth=auth)
                                if check_group.status_code == 200 and check_group.json().get('count', 0) > 0:
                                    current_group_id = check_group.json()['results'][0]['id']
                                    created_groups[current_group] = current_group_id
                                    print(f"âœ… Group exists: {current_group} (ID: {current_group_id})")
                                else:
                                    # ìƒˆ ê·¸ë£¹ ìƒì„±
                                    group_data = {
                                        "name": current_group,
                                        "description": f"Auto-created from inventory",
                                        "inventory": awx_inventory_id
                                    }
                                    group_res = await client.post(groups_url, auth=auth, json=group_data)
                                    if group_res.status_code in [200, 201]:
                                        current_group_id = group_res.json()['id']
                                        created_groups[current_group] = current_group_id
                                        print(f"âœ… Created group: {current_group} (ID: {current_group_id})")
                                    else:
                                        print(f"âš ï¸ Failed to create group {current_group}: {group_res.text}")
                                        current_group_id = None
                            except Exception as e:
                                print(f"âš ï¸ Error creating group {current_group}: {str(e)}")
                                current_group_id = None
                        else:
                            current_group_id = created_groups[current_group]
                    
                    continue
                
                # :vars/:children ì„¹ì…˜ ë‚´ë¶€ ìŠ¤í‚µ
                if skip_section:
                    print(f"ğŸš« Skip (special): {line[:60]}")
                    continue
                
                if not current_group:
                    continue
                
                parts = line.split()
                if not parts:
                    continue
                
                hostname = parts[0]
                
                # ë¹ˆ í˜¸ìŠ¤íŠ¸ëª…, íŠ¹ìˆ˜ë¬¸ì ì°¨ë‹¨
                if not hostname or len(hostname) < 2 or hostname in [';', '#', ',', '|', '']:
                    continue
                
                # = ìˆê³  ansible_ ì•„ë‹ˆë©´ ë³€ìˆ˜
                if '=' in hostname and not hostname.startswith('ansible_'):
                    print(f"ğŸš« Variable: {line[:60]}")
                    continue
                
                # ì–¸ë”ìŠ¤ì½”ì–´ ë³€ìˆ˜ íŒ¨í„´
                if '_' in hostname and not any(c in hostname for c in ['.', '-', '@', ':']):
                    print(f"ğŸš« Underscore var: {line[:60]}")
                    continue
                
                # ë³€ìˆ˜ í‚¤ì›Œë“œ ì°¨ë‹¨
                keywords = ['version', 'endpoint', 'iface', 'tunnel', 'plugins', 'kubernetes', 'containerd', 'runc', 'etcd', 'kube', 'cni']
                check_name = hostname.split('=')[0].lower() if '=' in hostname else hostname.lower()
                
                if check_name != 'localhost' and any(kw in check_name for kw in keywords):
                    print(f"ğŸš« Keyword: {line[:60]}")
                    continue
                
                # ì¤‘ë³µ ì²´í¬
                if hostname in added_hosts:
                    continue
                
                # í˜¸ìŠ¤íŠ¸ ë³€ìˆ˜ íŒŒì‹±
                host_vars = {}
                for part in parts[1:]:
                    if '=' in part:
                        key, value = part.split('=', 1)
                        host_vars[key] = value
                
                host_data = {
                    "name": hostname,
                    "description": f"Auto-created from inventory",
                    "enabled": True
                }
                
                if host_vars:
                    host_data["variables"] = yaml.dump(host_vars)
                
                try:
                    # ê¸°ì¡´ í˜¸ìŠ¤íŠ¸ ì²´í¬
                    check_url = f"{hosts_url}?name={hostname}"
                    check_res = await client.get(check_url, auth=auth)
                    
                    host_id = None
                    if check_res.status_code == 200 and check_res.json().get('count', 0) > 0:
                        host_id = check_res.json()['results'][0]['id']
                        print(f"Host exists: {hostname} (ID: {host_id})")
                        added_hosts.add(hostname)
                    else:
                        # ìƒˆ í˜¸ìŠ¤íŠ¸ ì¶”ê°€
                        host_res = await client.post(hosts_url, auth=auth, json=host_data)
                        if host_res.status_code in [200, 201]:
                            host_id = host_res.json()['id']
                            added_hosts.add(hostname)
                            print(f"âœ… Added host: {hostname} (ID: {host_id})")
                        else:
                            print(f"âš ï¸ Failed to add {hostname}: {host_res.text}")
                    
                    # í˜¸ìŠ¤íŠ¸ë¥¼ ê·¸ë£¹ì— ì¶”ê°€
                    if host_id and current_group_id:
                        associate_url = f"{request.awx_url}/api/v2/groups/{current_group_id}/hosts/"
                        associate_data = {"id": host_id}
                        associate_res = await client.post(associate_url, auth=auth, json=associate_data)
                        if associate_res.status_code in [200, 201, 204]:
                            print(f"âœ… Added {hostname} to group {current_group}")
                        else:
                            # ì´ë¯¸ ê·¸ë£¹ì— ì†í•´ìˆì„ ìˆ˜ ìˆìŒ (ë¬´ì‹œ)
                            print(f"â„¹ï¸ Host {hostname} association: {associate_res.status_code}")
                    
                except Exception as e:
                    print(f"âš ï¸ Error processing {hostname}: {str(e)}")
            
            # 4. Credential ì¡°íšŒ
            creds_url = f"{request.awx_url}/api/v2/credentials/"
            creds_res = await client.get(creds_url, auth=auth)
            credential_id = None
            
            if creds_res.status_code == 200:
                creds = creds_res.json()
                for cred in creds.get('results', []):
                    if 'gaia_bot' in cred.get('name', '').lower():
                        credential_id = cred['id']
                        print(f"Found gaia_bot credential: {cred['name']} (ID: {credential_id})")
                        break
                
                if not credential_id:
                    machine_creds_url = f"{request.awx_url}/api/v2/credentials/?credential_type=1"
                    machine_creds_res = await client.get(machine_creds_url, auth=auth)
                    if machine_creds_res.status_code == 200:
                        machine_creds = machine_creds_res.json()
                        if machine_creds.get('results'):
                            credential_id = machine_creds['results'][0]['id']
                            print(f"Using fallback credential: {machine_creds['results'][0]['name']} (ID: {credential_id})")
            
            # Job Template ìƒì„±
                template_res = await client.post(templates_url, auth=auth, json=template_data)
                if template_res.status_code not in [200, 201]:
                    raise HTTPException(status_code=400, detail=f"Failed to create job template: {template_res.text}")

                template_result = template_res.json()
                template_id = template_result['id']

                # â­ Survey ìƒì„±
                survey_spec = {
                    "name": "Ansible Builder Variables",
                    "description": "Dynamic playbook execution variables",
                    "spec": [
            {
                "question_name": "Builder Tasks JSON",
                "question_description": "JSON array of tasks to execute",
                "required": True,
                "type": "textarea",
                "variable": "builder_tasks",
                "min": 0,
                "max": 65536,
                "default": json.dumps(playbook_dict['tasks'])
            },
            {
                "question_name": "Target Hosts",
                "question_description": "Hosts pattern",
                "required": True,
                "type": "text",
                "variable": "target_hosts",
                "min": 0,
                "max": 1024,
                "default": playbook_dict['hosts']
            },
            {
                "question_name": "Become (sudo)",
                "question_description": "Run with elevated privileges",
                "required": True,
                "type": "multiplechoice",
                "variable": "become_required",
                "choices": ["true", "false"],
                "default": str(playbook_dict['become']).lower()
            }
        ]
    }
    
            survey_url = f"{request.awx_url}/api/v2/job_templates/{template_id}/survey_spec/"
            survey_res = await client.post(survey_url, auth=auth, json=survey_spec)

            if survey_res.status_code not in [200, 201]:
                print(f"âš ï¸ Survey creation failed: {survey_res.text}")

            return {
                "status": "success",
                "template_id": template_id,
                "template_name": template_name,
                "template_url": f"{request.awx_url}/#/templates/job_template/{template_id}",
                "message": "Job Template created with survey"
            }



            # 5. Job Template ìƒì„±
            template_name = f"{playbook_dict['name']}_{inventory_dict['name']}"
            templates_url = f"{request.awx_url}/api/v2/job_templates/"
            
            # ê¸°ì¡´ Template í™•ì¸
            template_check = await client.get(f"{templates_url}?name={template_name}", auth=auth)
            if template_check.status_code == 200 and template_check.json().get('count', 0) > 0:
                existing = template_check.json()['results'][0]
                return {
                    "status": "success",
                    "template_id": existing['id'],
                    "template_name": template_name,
                    "template_url": f"{request.awx_url}/#/templates/job_template/{existing['id']}",
                    "message": f"Job Template '{template_name}' already exists"
                }
            
            # Playbook YAMLì„ Projectì— ì—…ë¡œë“œí•˜ëŠ” ëŒ€ì‹ , 
            # AWXì˜ ê¸°ì¡´ playbookì„ ì‚¬ìš©í•˜ê³  extra_varsë¡œ ë™ì‘ ì œì–´
            # Demo Projectì—ì„œ ansible_builder_executor.yml ì‚¬ìš©
            demo_playbook_file = "ansible_builder_executor.yml"
            
            template_data = {
                "name": template_name,
                "description": f"Auto-created: {playbook_dict['name']} on {inventory_dict['name']}\n\nDynamic execution via extra_vars",
                "job_type": "run",
                "inventory": awx_inventory_id,
                "project": project_id,
                "playbook": demo_playbook_file,
                "verbosity": 1,
                "ask_variables_on_launch": True,
                "extra_vars": json.dumps({
                    "builder_playbook_name": playbook_dict['name'],
                    "target_hosts": playbook_dict['hosts'],
                    "become_required": playbook_dict['become'],
                    "builder_tasks": playbook_dict['tasks']
                }, indent=2)
            }
            
            if credential_id:
                template_data["credentials"] = [credential_id]
            
            template_res = await client.post(templates_url, auth=auth, json=template_data)
            if template_res.status_code not in [200, 201]:
                raise HTTPException(status_code=400, detail=f"Failed to create job template: {template_res.text}")
            
            template_result = template_res.json()
            
            return {
                "status": "success",
                "template_id": template_result['id'],
                "template_name": template_name,
                "template_url": f"{request.awx_url}/#/templates/job_template/{template_result['id']}",
                "project_id": project_id,
                "inventory_id": awx_inventory_id,
                "inventory_url": f"{request.awx_url}/#/inventories/inventory/{awx_inventory_id}/hosts",
                "credential_id": credential_id,
                "message": f"Job Template '{template_name}' created successfully"
            }
            
    except HTTPException:
        raise
    except httpx.RequestError as e:
        raise HTTPException(status_code=500, detail=f"Network error: {str(e)}")
    except Exception as e:
        import traceback
        error_detail = f"Error: {str(e)}\n{traceback.format_exc()}"
        print(error_detail)
        raise HTTPException(status_code=500, detail=error_detail)


@app.post("/api/awx/launch")
async def launch_awx_job(request: AWXJobRequest, db: Session = Depends(get_db)):
    """AWX Job ì‹¤í–‰ - extra_vars ì§ì ‘ ì „ë‹¬"""
    
    playbook = db.query(AnsibleBuilderPlaybook).filter(
        AnsibleBuilderPlaybook.id == request.playbook_id
    ).first()
    if not playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    playbook_dict = {
        "name": playbook.name,
        "hosts": playbook.hosts,
        "become": playbook.become,
        "tasks": json.loads(playbook.tasks)
    }
    
    try:
        async with httpx.AsyncClient(verify=False, timeout=60.0) as client:
            auth = (request.awx_username, request.awx_password)
            
            if not request.job_template_id:
                raise HTTPException(status_code=400, detail="Job Template ID required")
            
            # â­ Launch URL
            launch_url = f"{request.awx_url}/api/v2/job_templates/{request.job_template_id}/launch/"
            
            # â­ extra_vars ì¤€ë¹„
            extra_vars = {
                "builder_playbook_name": playbook_dict['name'],
                "target_hosts": playbook_dict['hosts'],
                "become_required": playbook_dict['become'],
                "builder_tasks": playbook_dict['tasks']
            }
            
            # â­ AWX API í˜•ì‹: extra_varsëŠ” JSON ë¬¸ìì—´ë¡œ ì „ë‹¬
            launch_payload = {
                "extra_vars": json.dumps(extra_vars)
            }
            
            print(f"ğŸš€ Launching job with payload:")
            print(json.dumps(launch_payload, indent=2))
            
            response = await client.post(launch_url, auth=auth, json=launch_payload)
            
            if response.status_code not in [200, 201]:
                raise HTTPException(
                    status_code=response.status_code,
                    detail=f"Launch failed: {response.text}"
                )
            
            job_result = response.json()
            job_id = job_result.get("id")
            
            return {
                "status": "success",
                "awx_job_id": job_id,
                "awx_job_url": f"{request.awx_url}/#/jobs/playbook/{job_id}",
                "playbook_name": playbook_dict['name'],
                "tasks_count": len(playbook_dict['tasks']),
                "message": f"Executing {len(playbook_dict['tasks'])} tasks"
            }
            
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))
    """AWX Job ì‹¤í–‰ - Template ì—…ë°ì´íŠ¸ í›„ Launch"""
    
    playbook = db.query(AnsibleBuilderPlaybook).filter(
        AnsibleBuilderPlaybook.id == request.playbook_id
    ).first()
    if not playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    playbook_dict = {
        "name": playbook.name,
        "hosts": playbook.hosts,
        "become": playbook.become,
        "tasks": json.loads(playbook.tasks)
    }
    
    try:
        async with httpx.AsyncClient(verify=False, timeout=60.0) as client:
            auth = (request.awx_username, request.awx_password)
            
            if not request.job_template_id:
                raise HTTPException(status_code=400, detail="Job Template ID required")
            
            template_url = f"{request.awx_url}/api/v2/job_templates/{request.job_template_id}/"
            
            # STEP 1: Template extra_vars ì—…ë°ì´íŠ¸
            extra_vars_data = {
                "builder_playbook_name": playbook_dict['name'],
                "target_hosts": playbook_dict['hosts'],
                "become_required": playbook_dict['become'],
                "builder_tasks": playbook_dict['tasks']
            }
            
            update_payload = {
                "extra_vars": json.dumps(extra_vars_data)
            }
            
            update_res = await client.patch(template_url, auth=auth, json=update_payload)
            
            if update_res.status_code not in [200, 201]:
                print(f"âš ï¸ Template update warning: {update_res.text}")
            
            # STEP 2: Launch Job
            launch_url = f"{request.awx_url}/api/v2/job_templates/{request.job_template_id}/launch/"
            
            response = await client.post(launch_url, auth=auth, json={})
            
            if response.status_code not in [200, 201]:
                raise HTTPException(
                    status_code=response.status_code,
                    detail=f"Launch failed: {response.text}"
                )
            
            job_result = response.json()
            job_id = job_result.get("id")
            
            return {
                "status": "success",
                "awx_job_id": job_id,
                "awx_job_url": f"{request.awx_url}/#/jobs/playbook/{job_id}",
                "tasks_count": len(playbook_dict['tasks']),
                "message": f"Executing {len(playbook_dict['tasks'])} tasks"
            }
            
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))
    """AWX Job ì‹¤í–‰ - Template ìˆ˜ì • í›„ Launch"""
    
    playbook = db.query(AnsibleBuilderPlaybook).filter(
        AnsibleBuilderPlaybook.id == request.playbook_id
    ).first()
    if not playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    playbook_dict = {
        "name": playbook.name,
        "hosts": playbook.hosts,
        "become": playbook.become,
        "tasks": json.loads(playbook.tasks)
    }
    
    try:
        async with httpx.AsyncClient(verify=False, timeout=60.0) as client:
            auth = (request.awx_username, request.awx_password)
            
            if not request.job_template_id:
                raise HTTPException(status_code=400, detail="Job Template ID required")
            
            template_url = f"{request.awx_url}/api/v2/job_templates/{request.job_template_id}/"
            
            # â­ STEP 1: Templateì˜ extra_vars ì—…ë°ì´íŠ¸
            extra_vars_data = {
                "builder_playbook_name": playbook_dict['name'],
                "target_hosts": playbook_dict['hosts'],
                "become_required": playbook_dict['become'],
                "builder_tasks": playbook_dict['tasks']
            }
            
            update_payload = {
                "extra_vars": json.dumps(extra_vars_data)
            }
            
            print(f"ğŸ“ Updating template with extra_vars:\n{json.dumps(extra_vars_data, indent=2)}")
            
            update_res = await client.patch(template_url, auth=auth, json=update_payload)
            
            if update_res.status_code not in [200, 201]:
                print(f"âš ï¸ Template update failed: {update_res.text}")
            else:
                print(f"âœ… Template updated successfully")
            
            # â­ STEP 2: Launch Job (extra_varsëŠ” ì´ë¯¸ Templateì— ì €ì¥ë¨)
            launch_url = f"{request.awx_url}/api/v2/job_templates/{request.job_template_id}/launch/"
            
            # ë¹ˆ payloadë¡œ launch (Templateì˜ extra_vars ì‚¬ìš©)
            launch_payload = {}
            
            response = await client.post(launch_url, auth=auth, json=launch_payload)
            
            if response.status_code not in [200, 201]:
                raise HTTPException(
                    status_code=response.status_code,
                    detail=f"Launch failed: {response.text}"
                )
            
            job_result = response.json()
            job_id = job_result.get("id")
            
            # Job ìƒì„¸ í™•ì¸
            await asyncio.sleep(1)
            job_detail_url = f"{request.awx_url}/api/v2/jobs/{job_id}/"
            job_detail_res = await client.get(job_detail_url, auth=auth)
            
            actual_vars = "unknown"
            if job_detail_res.status_code == 200:
                job_detail = job_detail_res.json()
                actual_vars = job_detail.get("extra_vars", "{}")
                print(f"âœ… Job {job_id} extra_vars:\n{actual_vars}")
            
            return {
                "status": "success",
                "awx_job_id": job_id,
                "awx_job_url": f"{request.awx_url}/#/jobs/playbook/{job_id}",
                "extra_vars_set": json.dumps(extra_vars_data, indent=2),
                "extra_vars_actual": actual_vars,
                "message": "Job launched successfully"
            }
            
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        error_detail = f"Error: {str(e)}\n{traceback.format_exc()}"
        print(error_detail)
        raise HTTPException(status_code=500, detail=error_detail)
    """AWX Job ì‹¤í–‰ - extra_vars ê°•ì œ ì£¼ì…"""
    
    playbook = db.query(AnsibleBuilderPlaybook).filter(
        AnsibleBuilderPlaybook.id == request.playbook_id
    ).first()
    if not playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    playbook_dict = {
        "name": playbook.name,
        "hosts": playbook.hosts,
        "become": playbook.become,
        "tasks": json.loads(playbook.tasks)
    }
    
    try:
        async with httpx.AsyncClient(verify=False, timeout=60.0) as client:
            auth = (request.awx_username, request.awx_password)
            
            if not request.job_template_id:
                raise HTTPException(status_code=400, detail="Job Template ID required")
            
            # â­ Launch ì „ì— Templateì˜ extra_vars í™•ì¸
            template_url = f"{request.awx_url}/api/v2/job_templates/{request.job_template_id}/"
            template_res = await client.get(template_url, auth=auth)
            
            if template_res.status_code != 200:
                raise HTTPException(status_code=404, detail="Template not found")
            
            template = template_res.json()
            
            # â­ ê¸°ì¡´ extra_varsì™€ ë³‘í•©
            existing_vars = json.loads(template.get('extra_vars', '{}'))
            
            # â­ ìƒˆë¡œìš´ extra_vars ìƒì„±
            new_extra_vars = {
                **existing_vars,  # ê¸°ì¡´ ë³€ìˆ˜ ìœ ì§€
                "builder_playbook_name": playbook_dict['name'],
                "target_hosts": playbook_dict['hosts'],
                "become_required": playbook_dict['become'],
                "builder_tasks": playbook_dict['tasks']
            }
            
            launch_url = f"{request.awx_url}/api/v2/job_templates/{request.job_template_id}/launch/"
            
            # â­ AWX API í˜•ì‹: extra_varsëŠ” JSON ë¬¸ìì—´
            job_data = {
                "extra_vars": json.dumps(new_extra_vars)
            }
            
            print(f"ğŸš€ Launching with extra_vars:\n{json.dumps(new_extra_vars, indent=2)}")
            
            response = await client.post(launch_url, auth=auth, json=job_data)
            
            if response.status_code not in [200, 201]:
                raise HTTPException(
                    status_code=response.status_code,
                    detail=f"Launch failed: {response.text}"
                )
            
            job_result = response.json()
            job_id = job_result.get("id")
            
            # â­ Job ìƒì„¸ ì¡°íšŒë¡œ ì‹¤ì œ ì ìš©ëœ extra_vars í™•ì¸
            await asyncio.sleep(1)  # Jobì´ ìƒì„±ë  ì‹œê°„ ëŒ€ê¸°
            job_detail_url = f"{request.awx_url}/api/v2/jobs/{job_id}/"
            job_detail_res = await client.get(job_detail_url, auth=auth)
            
            actual_vars = "unknown"
            if job_detail_res.status_code == 200:
                job_detail = job_detail_res.json()
                actual_vars = job_detail.get("extra_vars", "{}")
                print(f"âœ… Job created with extra_vars:\n{actual_vars}")
            
            return {
                "status": "success",
                "awx_job_id": job_id,
                "awx_job_url": f"{request.awx_url}/#/jobs/playbook/{job_id}",
                "extra_vars_sent": json.dumps(new_extra_vars, indent=2),
                "extra_vars_actual": actual_vars,
                "message": "Job launched successfully"
            }
            
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        error_detail = f"Error: {str(e)}\n{traceback.format_exc()}"
        print(error_detail)
        raise HTTPException(status_code=500, detail=error_detail)
    """AWX Job ì‹¤í–‰ - extra_vars ê°•ì œ ì£¼ì…"""
    
    playbook = db.query(AnsibleBuilderPlaybook).filter(
        AnsibleBuilderPlaybook.id == request.playbook_id
    ).first()
    if not playbook:
        raise HTTPException(status_code=404, detail="Playbook not found")
    
    playbook_dict = {
        "name": playbook.name,
        "hosts": playbook.hosts,
        "become": playbook.become,
        "tasks": json.loads(playbook.tasks)
    }
    
    try:
        async with httpx.AsyncClient(verify=False, timeout=60.0) as client:
            auth = (request.awx_username, request.awx_password)
            
            if not request.job_template_id:
                raise HTTPException(status_code=400, detail="Job Template ID required")
            
            # â­ extra_varsë¥¼ ë¬¸ìì—´ë¡œ ì „ë‹¬ (AWX ìš”êµ¬ì‚¬í•­)
            extra_vars_str = json.dumps({
                "builder_playbook_name": playbook_dict['name'],
                "target_hosts": playbook_dict['hosts'],
                "become_required": playbook_dict['become'],
                "builder_tasks": playbook_dict['tasks']
            })
            
            launch_url = f"{request.awx_url}/api/v2/job_templates/{request.job_template_id}/launch/"
            
            # â­ AWX API í˜•ì‹: extra_varsëŠ” ë¬¸ìì—´
            job_data = {
                "extra_vars": extra_vars_str
            }
            
            print(f"ğŸš€ Launching job with data: {json.dumps(job_data, indent=2)}")
            
            response = await client.post(launch_url, auth=auth, json=job_data)
            
            if response.status_code not in [200, 201]:
                raise HTTPException(
                    status_code=response.status_code,
                    detail=f"Launch failed: {response.text}"
                )
            
            job_result = response.json()
            job_id = job_result.get("id")
            
            # â­ Job ìƒì„¸ ì¡°íšŒë¡œ extra_vars í™•ì¸
            job_detail_url = f"{request.awx_url}/api/v2/jobs/{job_id}/"
            job_detail = await client.get(job_detail_url, auth=auth)
            
            actual_extra_vars = job_detail.json().get("extra_vars", "{}") if job_detail.status_code == 200 else "unknown"
            
            return {
                "status": "success",
                "awx_job_id": job_id,
                "awx_job_url": f"{request.awx_url}/#/jobs/playbook/{job_id}",
                "extra_vars_sent": extra_vars_str,
                "extra_vars_received": actual_extra_vars,
                "message": "Job launched"
            }
            
    except Exception as e:
        import traceback
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/awx/templates")
async def get_awx_templates(awx_url: str, awx_username: str, awx_password: str):
    """AWX Job Templates ëª©ë¡ ì¡°íšŒ"""
    try:
        async with httpx.AsyncClient(verify=False) as client:
            auth = (awx_username, awx_password)
            url = f"{awx_url}/api/v2/job_templates/"
            response = await client.get(url, auth=auth)
            
            if response.status_code != 200:
                raise HTTPException(status_code=400, detail="Failed to fetch templates from AWX")
            
            data = response.json()
            templates = [
                {"id": t["id"], "name": t["name"], "description": t.get("description", "")}
                for t in data.get("results", [])
            ]
            
            return {"templates": templates}
    except httpx.RequestError as e:
        raise HTTPException(status_code=500, detail=f"Failed to connect to AWX: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"AWX integration error: {str(e)}")

# inventory rebalance

@app.post("/api/inventories/import")
async def import_inventory_from_file(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """INI íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì—¬ Inventory ìë™ ìƒì„±"""
    try:
        content = await file.read()
        inventory_content = content.decode('utf-8')
        
        # íŒŒì¼ëª…ì—ì„œ ì¸ë²¤í† ë¦¬ ì´ë¦„ ì¶”ì¶œ
        inventory_name = file.filename.replace('.ini', '').replace('.txt', '')
        inventory_name = f"Imported_{inventory_name}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        
        # ì¸ë²¤í† ë¦¬ ë‚´ìš© ê²€ì¦
        if not inventory_content.strip():
            raise HTTPException(status_code=400, detail="Empty inventory file")
        
        # DBì— ì €ì¥
        db_inventory = AnsibleBuilderInventory(
            name=inventory_name,
            content=inventory_content
        )
        db.add(db_inventory)
        db.commit()
        db.refresh(db_inventory)
        
        # í˜¸ìŠ¤íŠ¸ ê°œìˆ˜ ì¹´ìš´íŠ¸
        host_count = len([line for line in inventory_content.split('\n') 
                         if line.strip() and not line.strip().startswith('[') 
                         and not line.strip().startswith('#')])
        
        return {
            "status": "success",
            "inventory_id": db_inventory.id,
            "inventory_name": inventory_name,
            "host_count": host_count,
            "message": f"Successfully imported inventory with {host_count} hosts"
        }
        
    except UnicodeDecodeError:
        raise HTTPException(status_code=400, detail="Invalid file encoding. Please use UTF-8")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Import failed: {str(e)}")


@app.post("/api/inventories/import-text")
async def import_inventory_from_text(data: dict, db: Session = Depends(get_db)):
    """í…ìŠ¤íŠ¸ë¡œ Inventory ëŒ€ëŸ‰ ìƒì„±"""
    try:
        inventory_text = data.get('content', '')
        inventory_name = data.get('name', f'Imported_Inventory_{datetime.utcnow().strftime("%Y%m%d_%H%M%S")}')
        
        if not inventory_text.strip():
            raise HTTPException(status_code=400, detail="Empty inventory content")
        
        # DBì— ì €ì¥
        db_inventory = AnsibleBuilderInventory(
            name=inventory_name,
            content=inventory_text
        )
        db.add(db_inventory)
        db.commit()
        db.refresh(db_inventory)
        
        # í˜¸ìŠ¤íŠ¸ ê°œìˆ˜ ì¹´ìš´íŠ¸
        host_count = len([line for line in inventory_text.split('\n') 
                         if line.strip() and not line.strip().startswith('[') 
                         and not line.strip().startswith('#')])
        
        return {
            "status": "success",
            "inventory_id": db_inventory.id,
            "inventory_name": inventory_name,
            "host_count": host_count,
            "message": f"Successfully imported inventory with {host_count} hosts"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Import failed: {str(e)}")


@app.post("/api/inventories/import-csv")
async def import_inventory_from_csv(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """CSV íŒŒì¼ì—ì„œ Inventory ìƒì„± (hostname,user,port,connection)"""
    try:
        content = await file.read()
        csv_content = content.decode('utf-8')
        
        lines = csv_content.strip().split('\n')
        if len(lines) < 2:
            raise HTTPException(status_code=400, detail="CSV must have header and at least one host")
        
        # í—¤ë” íŒŒì‹±
        header = [h.strip().lower() for h in lines[0].split(',')]
        
        # í•„ìˆ˜ ì»¬ëŸ¼ í™•ì¸
        if 'hostname' not in header and 'host' not in header:
            raise HTTPException(status_code=400, detail="CSV must have 'hostname' or 'host' column")
        
        hostname_idx = header.index('hostname') if 'hostname' in header else header.index('host')
        user_idx = header.index('user') if 'user' in header else header.index('ansible_user') if 'ansible_user' in header else None
        port_idx = header.index('port') if 'port' in header else header.index('ansible_port') if 'ansible_port' in header else None
        conn_idx = header.index('connection') if 'connection' in header else header.index('ansible_connection') if 'ansible_connection' in header else None
        group_idx = header.index('group') if 'group' in header else None
        
        # ê·¸ë£¹ë³„ë¡œ í˜¸ìŠ¤íŠ¸ ì •ë¦¬
        groups = {}
        for i, line in enumerate(lines[1:], start=2):
            if not line.strip():
                continue
            
            try:
                parts = [p.strip() for p in line.split(',')]
                hostname = parts[hostname_idx]
                
                if not hostname:
                    continue
                
                group = parts[group_idx] if group_idx is not None and group_idx < len(parts) else 'default'
                
                if group not in groups:
                    groups[group] = []
                
                host_line = hostname
                if user_idx is not None and user_idx < len(parts) and parts[user_idx]:
                    host_line += f" ansible_user={parts[user_idx]}"
                if port_idx is not None and port_idx < len(parts) and parts[port_idx]:
                    host_line += f" ansible_port={parts[port_idx]}"
                if conn_idx is not None and conn_idx < len(parts) and parts[conn_idx]:
                    host_line += f" ansible_connection={parts[conn_idx]}"
                
                groups[group].append(host_line)
                
            except IndexError as e:
                print(f"Warning: Skipping malformed line {i}: {line}")
                continue
        
        # INI í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        inventory_content = ""
        total_hosts = 0
        for group, hosts in groups.items():
            inventory_content += f"[{group}]\n"
            for host in hosts:
                inventory_content += f"{host}\n"
                total_hosts += 1
            inventory_content += "\n"
        
        # íŒŒì¼ëª…ì—ì„œ ì¸ë²¤í† ë¦¬ ì´ë¦„ ì¶”ì¶œ
        inventory_name = file.filename.replace('.csv', '')
        inventory_name = f"Imported_{inventory_name}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        
        # DBì— ì €ì¥
        db_inventory = AnsibleBuilderInventory(
            name=inventory_name,
            content=inventory_content.strip()
        )
        db.add(db_inventory)
        db.commit()
        db.refresh(db_inventory)
        
        return {
            "status": "success",
            "inventory_id": db_inventory.id,
            "inventory_name": inventory_name,
            "host_count": total_hosts,
            "group_count": len(groups),
            "message": f"Successfully imported {total_hosts} hosts in {len(groups)} groups"
        }
        
    except UnicodeDecodeError:
        raise HTTPException(status_code=400, detail="Invalid file encoding. Please use UTF-8")
    except Exception as e:
        import traceback
        error_detail = f"Import failed: {str(e)}\n{traceback.format_exc()}"
        print(error_detail)
        raise HTTPException(status_code=500, detail=f"Import failed: {str(e)}")


# AWX Executor Playbook ìë™ ì„¤ì •

EXECUTOR_PLAYBOOK_CONTENT = """---
- name: Ansible Builder Executor - DEEP DEBUG v2
  hosts: localhost
  connection: local
  gather_facts: no
  become: no

  tasks:
    - name: CONFIRMATION - This is the DEEP DEBUG v2 playbook
      ansible.builtin.debug:
        msg: "You are running the correct debugging playbook. Please provide the full output."

    - name: Display all available variables
      ansible.builtin.debug:
        var: hostvars[inventory_hostname]
"""

async def ensure_executor_playbook_exists(awx_url: str, awx_username: str, awx_password: str, project_id: int) -> tuple:
    """AWX Projectì— executor playbookì´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ì—†ìœ¼ë©´ ìƒì„± ì•ˆë‚´"""
    
    executor_filename = "ansible_builder_executor.yml"
    
    async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
        auth = (awx_username, awx_password)
        
        # Projectì˜ playbook ëª©ë¡ ì¡°íšŒ
        playbooks_url = f"{awx_url}/api/v2/projects/{project_id}/playbooks/"
        
        try:
            pb_res = await client.get(playbooks_url, auth=auth)
            if pb_res.status_code == 200:
                playbooks = pb_res.json()
                
                # executor playbookì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                if executor_filename in playbooks:
                    print(f"âœ… Executor playbook exists: {executor_filename}")
                    return (True, executor_filename, None)
                else:
                    print(f"âš ï¸ Executor playbook NOT found: {executor_filename}")
                    print(f"Available playbooks: {playbooks}")
                    
                    # Project ì •ë³´ ì¡°íšŒ
                    proj_res = await client.get(f"{awx_url}/api/v2/projects/{project_id}/", auth=auth)
                    if proj_res.status_code == 200:
                        project_info = proj_res.json()
                        project_name = project_info.get('name', 'Unknown')
                        scm_type = project_info.get('scm_type', '')
                        scm_url = project_info.get('scm_url', '')
                        local_path = project_info.get('local_path', '')
                        
                        print(f"Project: {project_name}, SCM: {scm_type}, Local: {local_path}")
                        
                        # SCM ê¸°ë°˜ í”„ë¡œì íŠ¸ì¸ ê²½ìš°
                        if scm_type in ['git', 'svn', 'hg']:
                            instructions = f"""â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâš™ï¸  EXECUTOR SETUP REQUIRED\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nProject: {project_name}\nType: {scm_type.upper()}\nRepository: {scm_url}\n\nSTEP 1: Add file to your repository\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nFile: {executor_filename}\nLocation: Root of repository\n\nSTEP 2: Commit and push\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ngit add {executor_filename}\ngit commit -m \"Add Ansible Builder executor\"\ngit push\n\nSTEP 3: Sync project in AWX\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nAWX â†’ Projects â†’ {project_name} â†’ Sync\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""
                            return (False, None, instructions)
                        
                        # Manual í”„ë¡œì íŠ¸ì¸ ê²½ìš°
                        else:
                            if local_path:
                                project_path = f"/var/lib/awx/projects/{local_path}"
                            else: 
                                # local_pathê°€ ì—†ìœ¼ë©´ project name ì‚¬ìš©
                                project_path = f"/var/lib/awx/projects/{project_name}"
                            
                            instructions = f"""â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâš™ï¸  EXECUTOR SETUP REQUIRED (Manual Project)\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nProject: {project_name}\nType: Manual\nPath: {project_path}\n\nRUN THIS ON AWX SERVER:\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nsudo mkdir -p {project_path}\nsudo chown awx:awx {project_path}\n\ncat > {project_path}/{executor_filename} << 'EOF'\n{EXECUTOR_PLAYBOOK_CONTENT}EOF\n\nsudo chown awx:awx {project_path}/{executor_filename}\n\nTHEN VERIFY:\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nls -la {project_path}/{executor_filename}\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nALTERNATIVE (if no SSH access):\nUse existing playbook temporarily until setup is complete.\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""
                            return (False, None, instructions)
                    
                    # ê¸°ë³¸ ì•ˆë‚´
                    return (False, None, "Executor playbook not found. Please add ansible_builder_executor.yml to your AWX project.")
        
        except Exception as e:
            error_msg = f"Error checking executor playbook: {str(e)}"
            print(error_msg)
            return (False, None, error_msg)
    
    return (False, None, "Unable to verify executor playbook")


@app.get("/api/awx/check-executor")
async def check_awx_executor(awx_url: str, awx_username: str, awx_password: str, project_id: int):
    """Executor playbook ì¡´ì¬ ì—¬ë¶€ í™•ì¸"""
    try:
        exists, filename, instructions = await ensure_executor_playbook_exists(
            awx_url, awx_username, awx_password, project_id
        )
        
        if exists:
            return {
                "status": "ready",
                "executor_playbook": filename,
                "message": "Executor playbook is available"
            }
        else:
            return {
                "status": "setup_required",
                "executor_playbook": None,
                "instructions": instructions,
                "playbook_content": EXECUTOR_PLAYBOOK_CONTENT
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ==================== ì¸ì¦ ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸ ====================

@app.get("/api/auth/keycloak-config")
async def get_keycloak_config():
    """í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ì‚¬ìš©í•  Keycloak ì„¤ì • ë°˜í™˜"""
    if not KEYCLOAK_ENABLED:
        raise HTTPException(
            status_code=503,
            detail="Keycloak integration is not enabled"
        )

    return {
        "enabled": True,
        "server_url": KEYCLOAK_SERVER_URL,
        "realm": KEYCLOAK_REALM,
        "client_id": KEYCLOAK_CLIENT_ID,
        "authorization_url": KEYCLOAK_AUTHORIZATION_URL,
        "token_url": KEYCLOAK_TOKEN_URL,
        "logout_url": KEYCLOAK_LOGOUT_URL
    }

@app.get("/api/auth/me")
async def get_me(current_user: AnsibleBuilderUser = Depends(require_keycloak_user)):
    """í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ì ì •ë³´ (Keycloak SSO)"""
    return {
        "id": current_user.id,
        "username": current_user.username,
        "email": current_user.email,
        "full_name": current_user.full_name,
        "role": current_user.role,
        "is_active": current_user.is_active
    }

@app.get("/api/auth/users")
async def list_users(
    current_user: AnsibleBuilderUser = Depends(get_current_user_keycloak),
    db: Session = Depends(get_db)
):
    """ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ (Admin only)"""
    users = db.query(AnsibleBuilderUser).all()
    return users

@app.delete("/api/auth/users/{user_id}")
async def delete_user(
    user_id: int,
    current_user: AnsibleBuilderUser = Depends(get_current_user_keycloak),
    db: Session = Depends(get_db)
):
    """ì‚¬ìš©ì ì‚­ì œ (Admin only)"""
    user = db.query(AnsibleBuilderUser).filter(AnsibleBuilderUser.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    if user.id == current_user.id:
        raise HTTPException(status_code=400, detail="Cannot delete yourself")

    username = user.username
    db.delete(user)
    db.commit()

    log_action(db, current_user, "DELETE", "user", user_id, f"Deleted user: {username}")

    return {"message": f"User {username} deleted successfully"}

# ==================== Frontend Static Files ====================

# Frontend ë¹Œë“œ íŒŒì¼ ê²½ë¡œ
FRONTEND_BUILD_DIR = os.path.join(os.path.dirname(__file__), "../frontend/frontend/dist")

# Static files (CSS, JS ë“±)
if os.path.exists(FRONTEND_BUILD_DIR):
    app.mount("/assets", StaticFiles(directory=os.path.join(FRONTEND_BUILD_DIR, "assets")), name="static")

    # ë£¨íŠ¸ ê²½ë¡œì™€ ëª¨ë“  SPA ê²½ë¡œëŠ” index.html ë°˜í™˜
    @app.get("/{full_path:path}")
    async def serve_frontend(full_path: str):
        """Frontend SPA ì„œë¹™"""
        # API ê²½ë¡œëŠ” ê±´ë„ˆëœ€
        if full_path.startswith("api/") or full_path.startswith("docs") or full_path.startswith("openapi.json"):
            raise HTTPException(status_code=404, detail="Not Found")

        # silent-check-sso.html íŠ¹ë³„ ì²˜ë¦¬
        if full_path == "silent-check-sso.html":
            return FileResponse(os.path.join(FRONTEND_BUILD_DIR, "silent-check-sso.html"))

        # vite.svg ë“± ì •ì  íŒŒì¼
        file_path = os.path.join(FRONTEND_BUILD_DIR, full_path)
        if os.path.isfile(file_path):
            return FileResponse(file_path)

        # ë‚˜ë¨¸ì§€ëŠ” ëª¨ë‘ index.html (SPA)
        return FileResponse(os.path.join(FRONTEND_BUILD_DIR, "index.html"))

    print(f"âœ“ Frontend served from: {FRONTEND_BUILD_DIR}")
else:
    print(f"âš  Frontend build directory not found: {FRONTEND_BUILD_DIR}")

if __name__ == "__main__":
    import uvicorn
    # 0.0.0.0 ìœ¼ë¡œ ë°”ì¸ë”©í•˜ì—¬ ì™¸ë¶€ ì ‘ì† í—ˆìš©
    uvicorn.run(app, host="0.0.0.0", port=8000)